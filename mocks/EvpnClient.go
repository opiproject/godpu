/* SPDX-License-Identifier: Apache-2.0
   Copyright (c) 2023 Dell Inc, or its subsidiaries.
*/
// Code generated by mockery v2.33.1. DO NOT EDIT.

package mocks

import (
	context "context"

	_go "github.com/opiproject/opi-api/network/evpn-gw/v1alpha1/gen/go"

	emptypb "google.golang.org/protobuf/types/known/emptypb"

	mock "github.com/stretchr/testify/mock"
)

// EvpnClient is an autogenerated mock type for the EvpnClient type
type EvpnClient struct {
	mock.Mock
}

type EvpnClient_Expecter struct {
	mock *mock.Mock
}

func (_m *EvpnClient) EXPECT() *EvpnClient_Expecter {
	return &EvpnClient_Expecter{mock: &_m.Mock}
}

// CreateBridgePort provides a mock function with given fields: ctx, name, mac, bridgePortType, logicalBridges
func (_m *EvpnClient) CreateBridgePort(ctx context.Context, name string, mac string, bridgePortType string, logicalBridges []string) (*_go.BridgePort, error) {
	ret := _m.Called(ctx, name, mac, bridgePortType, logicalBridges)

	var r0 *_go.BridgePort
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []string) (*_go.BridgePort, error)); ok {
		return rf(ctx, name, mac, bridgePortType, logicalBridges)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []string) *_go.BridgePort); ok {
		r0 = rf(ctx, name, mac, bridgePortType, logicalBridges)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.BridgePort)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, []string) error); ok {
		r1 = rf(ctx, name, mac, bridgePortType, logicalBridges)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_CreateBridgePort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBridgePort'
type EvpnClient_CreateBridgePort_Call struct {
	*mock.Call
}

// CreateBridgePort is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - mac string
//   - bridgePortType string
//   - logicalBridges []string
func (_e *EvpnClient_Expecter) CreateBridgePort(ctx interface{}, name interface{}, mac interface{}, bridgePortType interface{}, logicalBridges interface{}) *EvpnClient_CreateBridgePort_Call {
	return &EvpnClient_CreateBridgePort_Call{Call: _e.mock.On("CreateBridgePort", ctx, name, mac, bridgePortType, logicalBridges)}
}

func (_c *EvpnClient_CreateBridgePort_Call) Run(run func(ctx context.Context, name string, mac string, bridgePortType string, logicalBridges []string)) *EvpnClient_CreateBridgePort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].([]string))
	})
	return _c
}

func (_c *EvpnClient_CreateBridgePort_Call) Return(_a0 *_go.BridgePort, _a1 error) *EvpnClient_CreateBridgePort_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_CreateBridgePort_Call) RunAndReturn(run func(context.Context, string, string, string, []string) (*_go.BridgePort, error)) *EvpnClient_CreateBridgePort_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLogicalBridge provides a mock function with given fields: ctx, name, vlanID, vni
func (_m *EvpnClient) CreateLogicalBridge(ctx context.Context, name string, vlanID uint32, vni uint32) (*_go.LogicalBridge, error) {
	ret := _m.Called(ctx, name, vlanID, vni)

	var r0 *_go.LogicalBridge
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint32, uint32) (*_go.LogicalBridge, error)); ok {
		return rf(ctx, name, vlanID, vni)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint32, uint32) *_go.LogicalBridge); ok {
		r0 = rf(ctx, name, vlanID, vni)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.LogicalBridge)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint32, uint32) error); ok {
		r1 = rf(ctx, name, vlanID, vni)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_CreateLogicalBridge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLogicalBridge'
type EvpnClient_CreateLogicalBridge_Call struct {
	*mock.Call
}

// CreateLogicalBridge is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - vlanID uint32
//   - vni uint32
func (_e *EvpnClient_Expecter) CreateLogicalBridge(ctx interface{}, name interface{}, vlanID interface{}, vni interface{}) *EvpnClient_CreateLogicalBridge_Call {
	return &EvpnClient_CreateLogicalBridge_Call{Call: _e.mock.On("CreateLogicalBridge", ctx, name, vlanID, vni)}
}

func (_c *EvpnClient_CreateLogicalBridge_Call) Run(run func(ctx context.Context, name string, vlanID uint32, vni uint32)) *EvpnClient_CreateLogicalBridge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint32), args[3].(uint32))
	})
	return _c
}

func (_c *EvpnClient_CreateLogicalBridge_Call) Return(_a0 *_go.LogicalBridge, _a1 error) *EvpnClient_CreateLogicalBridge_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_CreateLogicalBridge_Call) RunAndReturn(run func(context.Context, string, uint32, uint32) (*_go.LogicalBridge, error)) *EvpnClient_CreateLogicalBridge_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSvi provides a mock function with given fields: ctx, name, vrf, logicalBridge, mac, gwIPs, ebgp, remoteAS
func (_m *EvpnClient) CreateSvi(ctx context.Context, name string, vrf string, logicalBridge string, mac string, gwIPs []string, ebgp bool, remoteAS uint32) (*_go.Svi, error) {
	ret := _m.Called(ctx, name, vrf, logicalBridge, mac, gwIPs, ebgp, remoteAS)

	var r0 *_go.Svi
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []string, bool, uint32) (*_go.Svi, error)); ok {
		return rf(ctx, name, vrf, logicalBridge, mac, gwIPs, ebgp, remoteAS)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, []string, bool, uint32) *_go.Svi); ok {
		r0 = rf(ctx, name, vrf, logicalBridge, mac, gwIPs, ebgp, remoteAS)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.Svi)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, []string, bool, uint32) error); ok {
		r1 = rf(ctx, name, vrf, logicalBridge, mac, gwIPs, ebgp, remoteAS)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_CreateSvi_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSvi'
type EvpnClient_CreateSvi_Call struct {
	*mock.Call
}

// CreateSvi is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - vrf string
//   - logicalBridge string
//   - mac string
//   - gwIPs []string
//   - ebgp bool
//   - remoteAS uint32
func (_e *EvpnClient_Expecter) CreateSvi(ctx interface{}, name interface{}, vrf interface{}, logicalBridge interface{}, mac interface{}, gwIPs interface{}, ebgp interface{}, remoteAS interface{}) *EvpnClient_CreateSvi_Call {
	return &EvpnClient_CreateSvi_Call{Call: _e.mock.On("CreateSvi", ctx, name, vrf, logicalBridge, mac, gwIPs, ebgp, remoteAS)}
}

func (_c *EvpnClient_CreateSvi_Call) Run(run func(ctx context.Context, name string, vrf string, logicalBridge string, mac string, gwIPs []string, ebgp bool, remoteAS uint32)) *EvpnClient_CreateSvi_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].([]string), args[6].(bool), args[7].(uint32))
	})
	return _c
}

func (_c *EvpnClient_CreateSvi_Call) Return(_a0 *_go.Svi, _a1 error) *EvpnClient_CreateSvi_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_CreateSvi_Call) RunAndReturn(run func(context.Context, string, string, string, string, []string, bool, uint32) (*_go.Svi, error)) *EvpnClient_CreateSvi_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVrf provides a mock function with given fields: ctx, name, vni, loopback, vtep
func (_m *EvpnClient) CreateVrf(ctx context.Context, name string, vni uint32, loopback string, vtep string) (*_go.Vrf, error) {
	ret := _m.Called(ctx, name, vni, loopback, vtep)

	var r0 *_go.Vrf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint32, string, string) (*_go.Vrf, error)); ok {
		return rf(ctx, name, vni, loopback, vtep)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint32, string, string) *_go.Vrf); ok {
		r0 = rf(ctx, name, vni, loopback, vtep)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.Vrf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint32, string, string) error); ok {
		r1 = rf(ctx, name, vni, loopback, vtep)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_CreateVrf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVrf'
type EvpnClient_CreateVrf_Call struct {
	*mock.Call
}

// CreateVrf is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - vni uint32
//   - loopback string
//   - vtep string
func (_e *EvpnClient_Expecter) CreateVrf(ctx interface{}, name interface{}, vni interface{}, loopback interface{}, vtep interface{}) *EvpnClient_CreateVrf_Call {
	return &EvpnClient_CreateVrf_Call{Call: _e.mock.On("CreateVrf", ctx, name, vni, loopback, vtep)}
}

func (_c *EvpnClient_CreateVrf_Call) Run(run func(ctx context.Context, name string, vni uint32, loopback string, vtep string)) *EvpnClient_CreateVrf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint32), args[3].(string), args[4].(string))
	})
	return _c
}

func (_c *EvpnClient_CreateVrf_Call) Return(_a0 *_go.Vrf, _a1 error) *EvpnClient_CreateVrf_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_CreateVrf_Call) RunAndReturn(run func(context.Context, string, uint32, string, string) (*_go.Vrf, error)) *EvpnClient_CreateVrf_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBridgePort provides a mock function with given fields: ctx, name, allowMissing
func (_m *EvpnClient) DeleteBridgePort(ctx context.Context, name string, allowMissing bool) (*emptypb.Empty, error) {
	ret := _m.Called(ctx, name, allowMissing)

	var r0 *emptypb.Empty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) (*emptypb.Empty, error)); ok {
		return rf(ctx, name, allowMissing)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) *emptypb.Empty); ok {
		r0 = rf(ctx, name, allowMissing)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = rf(ctx, name, allowMissing)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_DeleteBridgePort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBridgePort'
type EvpnClient_DeleteBridgePort_Call struct {
	*mock.Call
}

// DeleteBridgePort is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - allowMissing bool
func (_e *EvpnClient_Expecter) DeleteBridgePort(ctx interface{}, name interface{}, allowMissing interface{}) *EvpnClient_DeleteBridgePort_Call {
	return &EvpnClient_DeleteBridgePort_Call{Call: _e.mock.On("DeleteBridgePort", ctx, name, allowMissing)}
}

func (_c *EvpnClient_DeleteBridgePort_Call) Run(run func(ctx context.Context, name string, allowMissing bool)) *EvpnClient_DeleteBridgePort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *EvpnClient_DeleteBridgePort_Call) Return(_a0 *emptypb.Empty, _a1 error) *EvpnClient_DeleteBridgePort_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_DeleteBridgePort_Call) RunAndReturn(run func(context.Context, string, bool) (*emptypb.Empty, error)) *EvpnClient_DeleteBridgePort_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteLogicalBridge provides a mock function with given fields: ctx, name, allowMissing
func (_m *EvpnClient) DeleteLogicalBridge(ctx context.Context, name string, allowMissing bool) (*emptypb.Empty, error) {
	ret := _m.Called(ctx, name, allowMissing)

	var r0 *emptypb.Empty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) (*emptypb.Empty, error)); ok {
		return rf(ctx, name, allowMissing)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) *emptypb.Empty); ok {
		r0 = rf(ctx, name, allowMissing)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = rf(ctx, name, allowMissing)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_DeleteLogicalBridge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteLogicalBridge'
type EvpnClient_DeleteLogicalBridge_Call struct {
	*mock.Call
}

// DeleteLogicalBridge is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - allowMissing bool
func (_e *EvpnClient_Expecter) DeleteLogicalBridge(ctx interface{}, name interface{}, allowMissing interface{}) *EvpnClient_DeleteLogicalBridge_Call {
	return &EvpnClient_DeleteLogicalBridge_Call{Call: _e.mock.On("DeleteLogicalBridge", ctx, name, allowMissing)}
}

func (_c *EvpnClient_DeleteLogicalBridge_Call) Run(run func(ctx context.Context, name string, allowMissing bool)) *EvpnClient_DeleteLogicalBridge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *EvpnClient_DeleteLogicalBridge_Call) Return(_a0 *emptypb.Empty, _a1 error) *EvpnClient_DeleteLogicalBridge_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_DeleteLogicalBridge_Call) RunAndReturn(run func(context.Context, string, bool) (*emptypb.Empty, error)) *EvpnClient_DeleteLogicalBridge_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSvi provides a mock function with given fields: ctx, name, allowMissing
func (_m *EvpnClient) DeleteSvi(ctx context.Context, name string, allowMissing bool) (*emptypb.Empty, error) {
	ret := _m.Called(ctx, name, allowMissing)

	var r0 *emptypb.Empty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) (*emptypb.Empty, error)); ok {
		return rf(ctx, name, allowMissing)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) *emptypb.Empty); ok {
		r0 = rf(ctx, name, allowMissing)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = rf(ctx, name, allowMissing)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_DeleteSvi_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSvi'
type EvpnClient_DeleteSvi_Call struct {
	*mock.Call
}

// DeleteSvi is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - allowMissing bool
func (_e *EvpnClient_Expecter) DeleteSvi(ctx interface{}, name interface{}, allowMissing interface{}) *EvpnClient_DeleteSvi_Call {
	return &EvpnClient_DeleteSvi_Call{Call: _e.mock.On("DeleteSvi", ctx, name, allowMissing)}
}

func (_c *EvpnClient_DeleteSvi_Call) Run(run func(ctx context.Context, name string, allowMissing bool)) *EvpnClient_DeleteSvi_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *EvpnClient_DeleteSvi_Call) Return(_a0 *emptypb.Empty, _a1 error) *EvpnClient_DeleteSvi_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_DeleteSvi_Call) RunAndReturn(run func(context.Context, string, bool) (*emptypb.Empty, error)) *EvpnClient_DeleteSvi_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteVrf provides a mock function with given fields: ctx, name, allowMissing
func (_m *EvpnClient) DeleteVrf(ctx context.Context, name string, allowMissing bool) (*emptypb.Empty, error) {
	ret := _m.Called(ctx, name, allowMissing)

	var r0 *emptypb.Empty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) (*emptypb.Empty, error)); ok {
		return rf(ctx, name, allowMissing)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) *emptypb.Empty); ok {
		r0 = rf(ctx, name, allowMissing)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = rf(ctx, name, allowMissing)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_DeleteVrf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteVrf'
type EvpnClient_DeleteVrf_Call struct {
	*mock.Call
}

// DeleteVrf is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - allowMissing bool
func (_e *EvpnClient_Expecter) DeleteVrf(ctx interface{}, name interface{}, allowMissing interface{}) *EvpnClient_DeleteVrf_Call {
	return &EvpnClient_DeleteVrf_Call{Call: _e.mock.On("DeleteVrf", ctx, name, allowMissing)}
}

func (_c *EvpnClient_DeleteVrf_Call) Run(run func(ctx context.Context, name string, allowMissing bool)) *EvpnClient_DeleteVrf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *EvpnClient_DeleteVrf_Call) Return(_a0 *emptypb.Empty, _a1 error) *EvpnClient_DeleteVrf_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_DeleteVrf_Call) RunAndReturn(run func(context.Context, string, bool) (*emptypb.Empty, error)) *EvpnClient_DeleteVrf_Call {
	_c.Call.Return(run)
	return _c
}

// GetBridgePort provides a mock function with given fields: ctx, name
func (_m *EvpnClient) GetBridgePort(ctx context.Context, name string) (*_go.BridgePort, error) {
	ret := _m.Called(ctx, name)

	var r0 *_go.BridgePort
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*_go.BridgePort, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *_go.BridgePort); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.BridgePort)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_GetBridgePort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBridgePort'
type EvpnClient_GetBridgePort_Call struct {
	*mock.Call
}

// GetBridgePort is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *EvpnClient_Expecter) GetBridgePort(ctx interface{}, name interface{}) *EvpnClient_GetBridgePort_Call {
	return &EvpnClient_GetBridgePort_Call{Call: _e.mock.On("GetBridgePort", ctx, name)}
}

func (_c *EvpnClient_GetBridgePort_Call) Run(run func(ctx context.Context, name string)) *EvpnClient_GetBridgePort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *EvpnClient_GetBridgePort_Call) Return(_a0 *_go.BridgePort, _a1 error) *EvpnClient_GetBridgePort_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_GetBridgePort_Call) RunAndReturn(run func(context.Context, string) (*_go.BridgePort, error)) *EvpnClient_GetBridgePort_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogicalBridge provides a mock function with given fields: ctx, name
func (_m *EvpnClient) GetLogicalBridge(ctx context.Context, name string) (*_go.LogicalBridge, error) {
	ret := _m.Called(ctx, name)

	var r0 *_go.LogicalBridge
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*_go.LogicalBridge, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *_go.LogicalBridge); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.LogicalBridge)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_GetLogicalBridge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogicalBridge'
type EvpnClient_GetLogicalBridge_Call struct {
	*mock.Call
}

// GetLogicalBridge is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *EvpnClient_Expecter) GetLogicalBridge(ctx interface{}, name interface{}) *EvpnClient_GetLogicalBridge_Call {
	return &EvpnClient_GetLogicalBridge_Call{Call: _e.mock.On("GetLogicalBridge", ctx, name)}
}

func (_c *EvpnClient_GetLogicalBridge_Call) Run(run func(ctx context.Context, name string)) *EvpnClient_GetLogicalBridge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *EvpnClient_GetLogicalBridge_Call) Return(_a0 *_go.LogicalBridge, _a1 error) *EvpnClient_GetLogicalBridge_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_GetLogicalBridge_Call) RunAndReturn(run func(context.Context, string) (*_go.LogicalBridge, error)) *EvpnClient_GetLogicalBridge_Call {
	_c.Call.Return(run)
	return _c
}

// GetSvi provides a mock function with given fields: ctx, name
func (_m *EvpnClient) GetSvi(ctx context.Context, name string) (*_go.Svi, error) {
	ret := _m.Called(ctx, name)

	var r0 *_go.Svi
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*_go.Svi, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *_go.Svi); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.Svi)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_GetSvi_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSvi'
type EvpnClient_GetSvi_Call struct {
	*mock.Call
}

// GetSvi is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *EvpnClient_Expecter) GetSvi(ctx interface{}, name interface{}) *EvpnClient_GetSvi_Call {
	return &EvpnClient_GetSvi_Call{Call: _e.mock.On("GetSvi", ctx, name)}
}

func (_c *EvpnClient_GetSvi_Call) Run(run func(ctx context.Context, name string)) *EvpnClient_GetSvi_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *EvpnClient_GetSvi_Call) Return(_a0 *_go.Svi, _a1 error) *EvpnClient_GetSvi_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_GetSvi_Call) RunAndReturn(run func(context.Context, string) (*_go.Svi, error)) *EvpnClient_GetSvi_Call {
	_c.Call.Return(run)
	return _c
}

// GetVrf provides a mock function with given fields: ctx, name
func (_m *EvpnClient) GetVrf(ctx context.Context, name string) (*_go.Vrf, error) {
	ret := _m.Called(ctx, name)

	var r0 *_go.Vrf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*_go.Vrf, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *_go.Vrf); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.Vrf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_GetVrf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVrf'
type EvpnClient_GetVrf_Call struct {
	*mock.Call
}

// GetVrf is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *EvpnClient_Expecter) GetVrf(ctx interface{}, name interface{}) *EvpnClient_GetVrf_Call {
	return &EvpnClient_GetVrf_Call{Call: _e.mock.On("GetVrf", ctx, name)}
}

func (_c *EvpnClient_GetVrf_Call) Run(run func(ctx context.Context, name string)) *EvpnClient_GetVrf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *EvpnClient_GetVrf_Call) Return(_a0 *_go.Vrf, _a1 error) *EvpnClient_GetVrf_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_GetVrf_Call) RunAndReturn(run func(context.Context, string) (*_go.Vrf, error)) *EvpnClient_GetVrf_Call {
	_c.Call.Return(run)
	return _c
}

// ListBridgePorts provides a mock function with given fields: ctx, pageSize, pageToken
func (_m *EvpnClient) ListBridgePorts(ctx context.Context, pageSize int32, pageToken string) (*_go.ListBridgePortsResponse, error) {
	ret := _m.Called(ctx, pageSize, pageToken)

	var r0 *_go.ListBridgePortsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, string) (*_go.ListBridgePortsResponse, error)); ok {
		return rf(ctx, pageSize, pageToken)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, string) *_go.ListBridgePortsResponse); ok {
		r0 = rf(ctx, pageSize, pageToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.ListBridgePortsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, string) error); ok {
		r1 = rf(ctx, pageSize, pageToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_ListBridgePorts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBridgePorts'
type EvpnClient_ListBridgePorts_Call struct {
	*mock.Call
}

// ListBridgePorts is a helper method to define mock.On call
//   - ctx context.Context
//   - pageSize int32
//   - pageToken string
func (_e *EvpnClient_Expecter) ListBridgePorts(ctx interface{}, pageSize interface{}, pageToken interface{}) *EvpnClient_ListBridgePorts_Call {
	return &EvpnClient_ListBridgePorts_Call{Call: _e.mock.On("ListBridgePorts", ctx, pageSize, pageToken)}
}

func (_c *EvpnClient_ListBridgePorts_Call) Run(run func(ctx context.Context, pageSize int32, pageToken string)) *EvpnClient_ListBridgePorts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(string))
	})
	return _c
}

func (_c *EvpnClient_ListBridgePorts_Call) Return(_a0 *_go.ListBridgePortsResponse, _a1 error) *EvpnClient_ListBridgePorts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_ListBridgePorts_Call) RunAndReturn(run func(context.Context, int32, string) (*_go.ListBridgePortsResponse, error)) *EvpnClient_ListBridgePorts_Call {
	_c.Call.Return(run)
	return _c
}

// ListLogicalBridges provides a mock function with given fields: ctx, pageSize, pageToken
func (_m *EvpnClient) ListLogicalBridges(ctx context.Context, pageSize int32, pageToken string) (*_go.ListLogicalBridgesResponse, error) {
	ret := _m.Called(ctx, pageSize, pageToken)

	var r0 *_go.ListLogicalBridgesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, string) (*_go.ListLogicalBridgesResponse, error)); ok {
		return rf(ctx, pageSize, pageToken)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, string) *_go.ListLogicalBridgesResponse); ok {
		r0 = rf(ctx, pageSize, pageToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.ListLogicalBridgesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, string) error); ok {
		r1 = rf(ctx, pageSize, pageToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_ListLogicalBridges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListLogicalBridges'
type EvpnClient_ListLogicalBridges_Call struct {
	*mock.Call
}

// ListLogicalBridges is a helper method to define mock.On call
//   - ctx context.Context
//   - pageSize int32
//   - pageToken string
func (_e *EvpnClient_Expecter) ListLogicalBridges(ctx interface{}, pageSize interface{}, pageToken interface{}) *EvpnClient_ListLogicalBridges_Call {
	return &EvpnClient_ListLogicalBridges_Call{Call: _e.mock.On("ListLogicalBridges", ctx, pageSize, pageToken)}
}

func (_c *EvpnClient_ListLogicalBridges_Call) Run(run func(ctx context.Context, pageSize int32, pageToken string)) *EvpnClient_ListLogicalBridges_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(string))
	})
	return _c
}

func (_c *EvpnClient_ListLogicalBridges_Call) Return(_a0 *_go.ListLogicalBridgesResponse, _a1 error) *EvpnClient_ListLogicalBridges_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_ListLogicalBridges_Call) RunAndReturn(run func(context.Context, int32, string) (*_go.ListLogicalBridgesResponse, error)) *EvpnClient_ListLogicalBridges_Call {
	_c.Call.Return(run)
	return _c
}

// ListSvis provides a mock function with given fields: ctx, pageSize, pageToken
func (_m *EvpnClient) ListSvis(ctx context.Context, pageSize int32, pageToken string) (*_go.ListSvisResponse, error) {
	ret := _m.Called(ctx, pageSize, pageToken)

	var r0 *_go.ListSvisResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, string) (*_go.ListSvisResponse, error)); ok {
		return rf(ctx, pageSize, pageToken)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, string) *_go.ListSvisResponse); ok {
		r0 = rf(ctx, pageSize, pageToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.ListSvisResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, string) error); ok {
		r1 = rf(ctx, pageSize, pageToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_ListSvis_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSvis'
type EvpnClient_ListSvis_Call struct {
	*mock.Call
}

// ListSvis is a helper method to define mock.On call
//   - ctx context.Context
//   - pageSize int32
//   - pageToken string
func (_e *EvpnClient_Expecter) ListSvis(ctx interface{}, pageSize interface{}, pageToken interface{}) *EvpnClient_ListSvis_Call {
	return &EvpnClient_ListSvis_Call{Call: _e.mock.On("ListSvis", ctx, pageSize, pageToken)}
}

func (_c *EvpnClient_ListSvis_Call) Run(run func(ctx context.Context, pageSize int32, pageToken string)) *EvpnClient_ListSvis_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(string))
	})
	return _c
}

func (_c *EvpnClient_ListSvis_Call) Return(_a0 *_go.ListSvisResponse, _a1 error) *EvpnClient_ListSvis_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_ListSvis_Call) RunAndReturn(run func(context.Context, int32, string) (*_go.ListSvisResponse, error)) *EvpnClient_ListSvis_Call {
	_c.Call.Return(run)
	return _c
}

// ListVrfs provides a mock function with given fields: ctx, pageSize, pageToken
func (_m *EvpnClient) ListVrfs(ctx context.Context, pageSize int32, pageToken string) (*_go.ListVrfsResponse, error) {
	ret := _m.Called(ctx, pageSize, pageToken)

	var r0 *_go.ListVrfsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, string) (*_go.ListVrfsResponse, error)); ok {
		return rf(ctx, pageSize, pageToken)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, string) *_go.ListVrfsResponse); ok {
		r0 = rf(ctx, pageSize, pageToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.ListVrfsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, string) error); ok {
		r1 = rf(ctx, pageSize, pageToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_ListVrfs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListVrfs'
type EvpnClient_ListVrfs_Call struct {
	*mock.Call
}

// ListVrfs is a helper method to define mock.On call
//   - ctx context.Context
//   - pageSize int32
//   - pageToken string
func (_e *EvpnClient_Expecter) ListVrfs(ctx interface{}, pageSize interface{}, pageToken interface{}) *EvpnClient_ListVrfs_Call {
	return &EvpnClient_ListVrfs_Call{Call: _e.mock.On("ListVrfs", ctx, pageSize, pageToken)}
}

func (_c *EvpnClient_ListVrfs_Call) Run(run func(ctx context.Context, pageSize int32, pageToken string)) *EvpnClient_ListVrfs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(string))
	})
	return _c
}

func (_c *EvpnClient_ListVrfs_Call) Return(_a0 *_go.ListVrfsResponse, _a1 error) *EvpnClient_ListVrfs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_ListVrfs_Call) RunAndReturn(run func(context.Context, int32, string) (*_go.ListVrfsResponse, error)) *EvpnClient_ListVrfs_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBridgePort provides a mock function with given fields: ctx, name, updateMask, allowMissing
func (_m *EvpnClient) UpdateBridgePort(ctx context.Context, name string, updateMask []string, allowMissing bool) (*_go.BridgePort, error) {
	ret := _m.Called(ctx, name, updateMask, allowMissing)

	var r0 *_go.BridgePort
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, bool) (*_go.BridgePort, error)); ok {
		return rf(ctx, name, updateMask, allowMissing)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, bool) *_go.BridgePort); ok {
		r0 = rf(ctx, name, updateMask, allowMissing)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.BridgePort)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, bool) error); ok {
		r1 = rf(ctx, name, updateMask, allowMissing)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_UpdateBridgePort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBridgePort'
type EvpnClient_UpdateBridgePort_Call struct {
	*mock.Call
}

// UpdateBridgePort is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - updateMask []string
//   - allowMissing bool
func (_e *EvpnClient_Expecter) UpdateBridgePort(ctx interface{}, name interface{}, updateMask interface{}, allowMissing interface{}) *EvpnClient_UpdateBridgePort_Call {
	return &EvpnClient_UpdateBridgePort_Call{Call: _e.mock.On("UpdateBridgePort", ctx, name, updateMask, allowMissing)}
}

func (_c *EvpnClient_UpdateBridgePort_Call) Run(run func(ctx context.Context, name string, updateMask []string, allowMissing bool)) *EvpnClient_UpdateBridgePort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(bool))
	})
	return _c
}

func (_c *EvpnClient_UpdateBridgePort_Call) Return(_a0 *_go.BridgePort, _a1 error) *EvpnClient_UpdateBridgePort_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_UpdateBridgePort_Call) RunAndReturn(run func(context.Context, string, []string, bool) (*_go.BridgePort, error)) *EvpnClient_UpdateBridgePort_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateLogicalBridge provides a mock function with given fields: ctx, name, updateMask
func (_m *EvpnClient) UpdateLogicalBridge(ctx context.Context, name string, updateMask []string) (*_go.LogicalBridge, error) {
	ret := _m.Called(ctx, name, updateMask)

	var r0 *_go.LogicalBridge
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) (*_go.LogicalBridge, error)); ok {
		return rf(ctx, name, updateMask)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) *_go.LogicalBridge); ok {
		r0 = rf(ctx, name, updateMask)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.LogicalBridge)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, name, updateMask)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_UpdateLogicalBridge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateLogicalBridge'
type EvpnClient_UpdateLogicalBridge_Call struct {
	*mock.Call
}

// UpdateLogicalBridge is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - updateMask []string
func (_e *EvpnClient_Expecter) UpdateLogicalBridge(ctx interface{}, name interface{}, updateMask interface{}) *EvpnClient_UpdateLogicalBridge_Call {
	return &EvpnClient_UpdateLogicalBridge_Call{Call: _e.mock.On("UpdateLogicalBridge", ctx, name, updateMask)}
}

func (_c *EvpnClient_UpdateLogicalBridge_Call) Run(run func(ctx context.Context, name string, updateMask []string)) *EvpnClient_UpdateLogicalBridge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string))
	})
	return _c
}

func (_c *EvpnClient_UpdateLogicalBridge_Call) Return(_a0 *_go.LogicalBridge, _a1 error) *EvpnClient_UpdateLogicalBridge_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_UpdateLogicalBridge_Call) RunAndReturn(run func(context.Context, string, []string) (*_go.LogicalBridge, error)) *EvpnClient_UpdateLogicalBridge_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSvi provides a mock function with given fields: ctx, name, updateMask, allowMissing
func (_m *EvpnClient) UpdateSvi(ctx context.Context, name string, updateMask []string, allowMissing bool) (*_go.Svi, error) {
	ret := _m.Called(ctx, name, updateMask, allowMissing)

	var r0 *_go.Svi
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, bool) (*_go.Svi, error)); ok {
		return rf(ctx, name, updateMask, allowMissing)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, bool) *_go.Svi); ok {
		r0 = rf(ctx, name, updateMask, allowMissing)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.Svi)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, bool) error); ok {
		r1 = rf(ctx, name, updateMask, allowMissing)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_UpdateSvi_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSvi'
type EvpnClient_UpdateSvi_Call struct {
	*mock.Call
}

// UpdateSvi is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - updateMask []string
//   - allowMissing bool
func (_e *EvpnClient_Expecter) UpdateSvi(ctx interface{}, name interface{}, updateMask interface{}, allowMissing interface{}) *EvpnClient_UpdateSvi_Call {
	return &EvpnClient_UpdateSvi_Call{Call: _e.mock.On("UpdateSvi", ctx, name, updateMask, allowMissing)}
}

func (_c *EvpnClient_UpdateSvi_Call) Run(run func(ctx context.Context, name string, updateMask []string, allowMissing bool)) *EvpnClient_UpdateSvi_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(bool))
	})
	return _c
}

func (_c *EvpnClient_UpdateSvi_Call) Return(_a0 *_go.Svi, _a1 error) *EvpnClient_UpdateSvi_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_UpdateSvi_Call) RunAndReturn(run func(context.Context, string, []string, bool) (*_go.Svi, error)) *EvpnClient_UpdateSvi_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateVrf provides a mock function with given fields: ctx, name, updateMask, allowMissing
func (_m *EvpnClient) UpdateVrf(ctx context.Context, name string, updateMask []string, allowMissing bool) (*_go.Vrf, error) {
	ret := _m.Called(ctx, name, updateMask, allowMissing)

	var r0 *_go.Vrf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, bool) (*_go.Vrf, error)); ok {
		return rf(ctx, name, updateMask, allowMissing)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, bool) *_go.Vrf); ok {
		r0 = rf(ctx, name, updateMask, allowMissing)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.Vrf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, bool) error); ok {
		r1 = rf(ctx, name, updateMask, allowMissing)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EvpnClient_UpdateVrf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateVrf'
type EvpnClient_UpdateVrf_Call struct {
	*mock.Call
}

// UpdateVrf is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - updateMask []string
//   - allowMissing bool
func (_e *EvpnClient_Expecter) UpdateVrf(ctx interface{}, name interface{}, updateMask interface{}, allowMissing interface{}) *EvpnClient_UpdateVrf_Call {
	return &EvpnClient_UpdateVrf_Call{Call: _e.mock.On("UpdateVrf", ctx, name, updateMask, allowMissing)}
}

func (_c *EvpnClient_UpdateVrf_Call) Run(run func(ctx context.Context, name string, updateMask []string, allowMissing bool)) *EvpnClient_UpdateVrf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(bool))
	})
	return _c
}

func (_c *EvpnClient_UpdateVrf_Call) Return(_a0 *_go.Vrf, _a1 error) *EvpnClient_UpdateVrf_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *EvpnClient_UpdateVrf_Call) RunAndReturn(run func(context.Context, string, []string, bool) (*_go.Vrf, error)) *EvpnClient_UpdateVrf_Call {
	_c.Call.Return(run)
	return _c
}

// NewEvpnClient creates a new instance of EvpnClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewEvpnClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *EvpnClient {
	mock := &EvpnClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
