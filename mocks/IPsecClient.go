/* SPDX-License-Identifier: Apache-2.0
   Copyright (c) 2023 Dell Inc, or its subsidiaries.
*/
// Code generated by mockery v2.33.1. DO NOT EDIT.

package mocks

import (
	context "context"

	_go "github.com/opiproject/opi-api/security/v1/gen/go"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"
)

// IPsecClient is an autogenerated mock type for the IPsecClient type
type IPsecClient struct {
	mock.Mock
}

type IPsecClient_Expecter struct {
	mock *mock.Mock
}

func (_m *IPsecClient) EXPECT() *IPsecClient_Expecter {
	return &IPsecClient_Expecter{mock: &_m.Mock}
}

// IPsecInitiate provides a mock function with given fields: ctx, in, opts
func (_m *IPsecClient) IPsecInitiate(ctx context.Context, in *_go.IPsecInitiateReq, opts ...grpc.CallOption) (*_go.IPsecInitiateResp, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *_go.IPsecInitiateResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecInitiateReq, ...grpc.CallOption) (*_go.IPsecInitiateResp, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecInitiateReq, ...grpc.CallOption) *_go.IPsecInitiateResp); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.IPsecInitiateResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *_go.IPsecInitiateReq, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPsecClient_IPsecInitiate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IPsecInitiate'
type IPsecClient_IPsecInitiate_Call struct {
	*mock.Call
}

// IPsecInitiate is a helper method to define mock.On call
//   - ctx context.Context
//   - in *_go.IPsecInitiateReq
//   - opts ...grpc.CallOption
func (_e *IPsecClient_Expecter) IPsecInitiate(ctx interface{}, in interface{}, opts ...interface{}) *IPsecClient_IPsecInitiate_Call {
	return &IPsecClient_IPsecInitiate_Call{Call: _e.mock.On("IPsecInitiate",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *IPsecClient_IPsecInitiate_Call) Run(run func(ctx context.Context, in *_go.IPsecInitiateReq, opts ...grpc.CallOption)) *IPsecClient_IPsecInitiate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*_go.IPsecInitiateReq), variadicArgs...)
	})
	return _c
}

func (_c *IPsecClient_IPsecInitiate_Call) Return(_a0 *_go.IPsecInitiateResp, _a1 error) *IPsecClient_IPsecInitiate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IPsecClient_IPsecInitiate_Call) RunAndReturn(run func(context.Context, *_go.IPsecInitiateReq, ...grpc.CallOption) (*_go.IPsecInitiateResp, error)) *IPsecClient_IPsecInitiate_Call {
	_c.Call.Return(run)
	return _c
}

// IPsecListCerts provides a mock function with given fields: ctx, in, opts
func (_m *IPsecClient) IPsecListCerts(ctx context.Context, in *_go.IPsecListCertsReq, opts ...grpc.CallOption) (*_go.IPsecListCertsResp, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *_go.IPsecListCertsResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecListCertsReq, ...grpc.CallOption) (*_go.IPsecListCertsResp, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecListCertsReq, ...grpc.CallOption) *_go.IPsecListCertsResp); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.IPsecListCertsResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *_go.IPsecListCertsReq, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPsecClient_IPsecListCerts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IPsecListCerts'
type IPsecClient_IPsecListCerts_Call struct {
	*mock.Call
}

// IPsecListCerts is a helper method to define mock.On call
//   - ctx context.Context
//   - in *_go.IPsecListCertsReq
//   - opts ...grpc.CallOption
func (_e *IPsecClient_Expecter) IPsecListCerts(ctx interface{}, in interface{}, opts ...interface{}) *IPsecClient_IPsecListCerts_Call {
	return &IPsecClient_IPsecListCerts_Call{Call: _e.mock.On("IPsecListCerts",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *IPsecClient_IPsecListCerts_Call) Run(run func(ctx context.Context, in *_go.IPsecListCertsReq, opts ...grpc.CallOption)) *IPsecClient_IPsecListCerts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*_go.IPsecListCertsReq), variadicArgs...)
	})
	return _c
}

func (_c *IPsecClient_IPsecListCerts_Call) Return(_a0 *_go.IPsecListCertsResp, _a1 error) *IPsecClient_IPsecListCerts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IPsecClient_IPsecListCerts_Call) RunAndReturn(run func(context.Context, *_go.IPsecListCertsReq, ...grpc.CallOption) (*_go.IPsecListCertsResp, error)) *IPsecClient_IPsecListCerts_Call {
	_c.Call.Return(run)
	return _c
}

// IPsecListConns provides a mock function with given fields: ctx, in, opts
func (_m *IPsecClient) IPsecListConns(ctx context.Context, in *_go.IPsecListConnsReq, opts ...grpc.CallOption) (*_go.IPsecListConnsResp, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *_go.IPsecListConnsResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecListConnsReq, ...grpc.CallOption) (*_go.IPsecListConnsResp, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecListConnsReq, ...grpc.CallOption) *_go.IPsecListConnsResp); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.IPsecListConnsResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *_go.IPsecListConnsReq, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPsecClient_IPsecListConns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IPsecListConns'
type IPsecClient_IPsecListConns_Call struct {
	*mock.Call
}

// IPsecListConns is a helper method to define mock.On call
//   - ctx context.Context
//   - in *_go.IPsecListConnsReq
//   - opts ...grpc.CallOption
func (_e *IPsecClient_Expecter) IPsecListConns(ctx interface{}, in interface{}, opts ...interface{}) *IPsecClient_IPsecListConns_Call {
	return &IPsecClient_IPsecListConns_Call{Call: _e.mock.On("IPsecListConns",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *IPsecClient_IPsecListConns_Call) Run(run func(ctx context.Context, in *_go.IPsecListConnsReq, opts ...grpc.CallOption)) *IPsecClient_IPsecListConns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*_go.IPsecListConnsReq), variadicArgs...)
	})
	return _c
}

func (_c *IPsecClient_IPsecListConns_Call) Return(_a0 *_go.IPsecListConnsResp, _a1 error) *IPsecClient_IPsecListConns_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IPsecClient_IPsecListConns_Call) RunAndReturn(run func(context.Context, *_go.IPsecListConnsReq, ...grpc.CallOption) (*_go.IPsecListConnsResp, error)) *IPsecClient_IPsecListConns_Call {
	_c.Call.Return(run)
	return _c
}

// IPsecListSas provides a mock function with given fields: ctx, in, opts
func (_m *IPsecClient) IPsecListSas(ctx context.Context, in *_go.IPsecListSasReq, opts ...grpc.CallOption) (*_go.IPsecListSasResp, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *_go.IPsecListSasResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecListSasReq, ...grpc.CallOption) (*_go.IPsecListSasResp, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecListSasReq, ...grpc.CallOption) *_go.IPsecListSasResp); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.IPsecListSasResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *_go.IPsecListSasReq, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPsecClient_IPsecListSas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IPsecListSas'
type IPsecClient_IPsecListSas_Call struct {
	*mock.Call
}

// IPsecListSas is a helper method to define mock.On call
//   - ctx context.Context
//   - in *_go.IPsecListSasReq
//   - opts ...grpc.CallOption
func (_e *IPsecClient_Expecter) IPsecListSas(ctx interface{}, in interface{}, opts ...interface{}) *IPsecClient_IPsecListSas_Call {
	return &IPsecClient_IPsecListSas_Call{Call: _e.mock.On("IPsecListSas",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *IPsecClient_IPsecListSas_Call) Run(run func(ctx context.Context, in *_go.IPsecListSasReq, opts ...grpc.CallOption)) *IPsecClient_IPsecListSas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*_go.IPsecListSasReq), variadicArgs...)
	})
	return _c
}

func (_c *IPsecClient_IPsecListSas_Call) Return(_a0 *_go.IPsecListSasResp, _a1 error) *IPsecClient_IPsecListSas_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IPsecClient_IPsecListSas_Call) RunAndReturn(run func(context.Context, *_go.IPsecListSasReq, ...grpc.CallOption) (*_go.IPsecListSasResp, error)) *IPsecClient_IPsecListSas_Call {
	_c.Call.Return(run)
	return _c
}

// IPsecLoadConn provides a mock function with given fields: ctx, in, opts
func (_m *IPsecClient) IPsecLoadConn(ctx context.Context, in *_go.IPsecLoadConnReq, opts ...grpc.CallOption) (*_go.IPsecLoadConnResp, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *_go.IPsecLoadConnResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecLoadConnReq, ...grpc.CallOption) (*_go.IPsecLoadConnResp, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecLoadConnReq, ...grpc.CallOption) *_go.IPsecLoadConnResp); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.IPsecLoadConnResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *_go.IPsecLoadConnReq, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPsecClient_IPsecLoadConn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IPsecLoadConn'
type IPsecClient_IPsecLoadConn_Call struct {
	*mock.Call
}

// IPsecLoadConn is a helper method to define mock.On call
//   - ctx context.Context
//   - in *_go.IPsecLoadConnReq
//   - opts ...grpc.CallOption
func (_e *IPsecClient_Expecter) IPsecLoadConn(ctx interface{}, in interface{}, opts ...interface{}) *IPsecClient_IPsecLoadConn_Call {
	return &IPsecClient_IPsecLoadConn_Call{Call: _e.mock.On("IPsecLoadConn",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *IPsecClient_IPsecLoadConn_Call) Run(run func(ctx context.Context, in *_go.IPsecLoadConnReq, opts ...grpc.CallOption)) *IPsecClient_IPsecLoadConn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*_go.IPsecLoadConnReq), variadicArgs...)
	})
	return _c
}

func (_c *IPsecClient_IPsecLoadConn_Call) Return(_a0 *_go.IPsecLoadConnResp, _a1 error) *IPsecClient_IPsecLoadConn_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IPsecClient_IPsecLoadConn_Call) RunAndReturn(run func(context.Context, *_go.IPsecLoadConnReq, ...grpc.CallOption) (*_go.IPsecLoadConnResp, error)) *IPsecClient_IPsecLoadConn_Call {
	_c.Call.Return(run)
	return _c
}

// IPsecRekey provides a mock function with given fields: ctx, in, opts
func (_m *IPsecClient) IPsecRekey(ctx context.Context, in *_go.IPsecRekeyReq, opts ...grpc.CallOption) (*_go.IPsecRekeyResp, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *_go.IPsecRekeyResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecRekeyReq, ...grpc.CallOption) (*_go.IPsecRekeyResp, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecRekeyReq, ...grpc.CallOption) *_go.IPsecRekeyResp); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.IPsecRekeyResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *_go.IPsecRekeyReq, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPsecClient_IPsecRekey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IPsecRekey'
type IPsecClient_IPsecRekey_Call struct {
	*mock.Call
}

// IPsecRekey is a helper method to define mock.On call
//   - ctx context.Context
//   - in *_go.IPsecRekeyReq
//   - opts ...grpc.CallOption
func (_e *IPsecClient_Expecter) IPsecRekey(ctx interface{}, in interface{}, opts ...interface{}) *IPsecClient_IPsecRekey_Call {
	return &IPsecClient_IPsecRekey_Call{Call: _e.mock.On("IPsecRekey",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *IPsecClient_IPsecRekey_Call) Run(run func(ctx context.Context, in *_go.IPsecRekeyReq, opts ...grpc.CallOption)) *IPsecClient_IPsecRekey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*_go.IPsecRekeyReq), variadicArgs...)
	})
	return _c
}

func (_c *IPsecClient_IPsecRekey_Call) Return(_a0 *_go.IPsecRekeyResp, _a1 error) *IPsecClient_IPsecRekey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IPsecClient_IPsecRekey_Call) RunAndReturn(run func(context.Context, *_go.IPsecRekeyReq, ...grpc.CallOption) (*_go.IPsecRekeyResp, error)) *IPsecClient_IPsecRekey_Call {
	_c.Call.Return(run)
	return _c
}

// IPsecStats provides a mock function with given fields: ctx, in, opts
func (_m *IPsecClient) IPsecStats(ctx context.Context, in *_go.IPsecStatsReq, opts ...grpc.CallOption) (*_go.IPsecStatsResp, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *_go.IPsecStatsResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecStatsReq, ...grpc.CallOption) (*_go.IPsecStatsResp, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecStatsReq, ...grpc.CallOption) *_go.IPsecStatsResp); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.IPsecStatsResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *_go.IPsecStatsReq, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPsecClient_IPsecStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IPsecStats'
type IPsecClient_IPsecStats_Call struct {
	*mock.Call
}

// IPsecStats is a helper method to define mock.On call
//   - ctx context.Context
//   - in *_go.IPsecStatsReq
//   - opts ...grpc.CallOption
func (_e *IPsecClient_Expecter) IPsecStats(ctx interface{}, in interface{}, opts ...interface{}) *IPsecClient_IPsecStats_Call {
	return &IPsecClient_IPsecStats_Call{Call: _e.mock.On("IPsecStats",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *IPsecClient_IPsecStats_Call) Run(run func(ctx context.Context, in *_go.IPsecStatsReq, opts ...grpc.CallOption)) *IPsecClient_IPsecStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*_go.IPsecStatsReq), variadicArgs...)
	})
	return _c
}

func (_c *IPsecClient_IPsecStats_Call) Return(_a0 *_go.IPsecStatsResp, _a1 error) *IPsecClient_IPsecStats_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IPsecClient_IPsecStats_Call) RunAndReturn(run func(context.Context, *_go.IPsecStatsReq, ...grpc.CallOption) (*_go.IPsecStatsResp, error)) *IPsecClient_IPsecStats_Call {
	_c.Call.Return(run)
	return _c
}

// IPsecTerminate provides a mock function with given fields: ctx, in, opts
func (_m *IPsecClient) IPsecTerminate(ctx context.Context, in *_go.IPsecTerminateReq, opts ...grpc.CallOption) (*_go.IPsecTerminateResp, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *_go.IPsecTerminateResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecTerminateReq, ...grpc.CallOption) (*_go.IPsecTerminateResp, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecTerminateReq, ...grpc.CallOption) *_go.IPsecTerminateResp); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.IPsecTerminateResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *_go.IPsecTerminateReq, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPsecClient_IPsecTerminate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IPsecTerminate'
type IPsecClient_IPsecTerminate_Call struct {
	*mock.Call
}

// IPsecTerminate is a helper method to define mock.On call
//   - ctx context.Context
//   - in *_go.IPsecTerminateReq
//   - opts ...grpc.CallOption
func (_e *IPsecClient_Expecter) IPsecTerminate(ctx interface{}, in interface{}, opts ...interface{}) *IPsecClient_IPsecTerminate_Call {
	return &IPsecClient_IPsecTerminate_Call{Call: _e.mock.On("IPsecTerminate",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *IPsecClient_IPsecTerminate_Call) Run(run func(ctx context.Context, in *_go.IPsecTerminateReq, opts ...grpc.CallOption)) *IPsecClient_IPsecTerminate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*_go.IPsecTerminateReq), variadicArgs...)
	})
	return _c
}

func (_c *IPsecClient_IPsecTerminate_Call) Return(_a0 *_go.IPsecTerminateResp, _a1 error) *IPsecClient_IPsecTerminate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IPsecClient_IPsecTerminate_Call) RunAndReturn(run func(context.Context, *_go.IPsecTerminateReq, ...grpc.CallOption) (*_go.IPsecTerminateResp, error)) *IPsecClient_IPsecTerminate_Call {
	_c.Call.Return(run)
	return _c
}

// IPsecUnloadConn provides a mock function with given fields: ctx, in, opts
func (_m *IPsecClient) IPsecUnloadConn(ctx context.Context, in *_go.IPsecUnloadConnReq, opts ...grpc.CallOption) (*_go.IPsecUnloadConnResp, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *_go.IPsecUnloadConnResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecUnloadConnReq, ...grpc.CallOption) (*_go.IPsecUnloadConnResp, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecUnloadConnReq, ...grpc.CallOption) *_go.IPsecUnloadConnResp); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.IPsecUnloadConnResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *_go.IPsecUnloadConnReq, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPsecClient_IPsecUnloadConn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IPsecUnloadConn'
type IPsecClient_IPsecUnloadConn_Call struct {
	*mock.Call
}

// IPsecUnloadConn is a helper method to define mock.On call
//   - ctx context.Context
//   - in *_go.IPsecUnloadConnReq
//   - opts ...grpc.CallOption
func (_e *IPsecClient_Expecter) IPsecUnloadConn(ctx interface{}, in interface{}, opts ...interface{}) *IPsecClient_IPsecUnloadConn_Call {
	return &IPsecClient_IPsecUnloadConn_Call{Call: _e.mock.On("IPsecUnloadConn",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *IPsecClient_IPsecUnloadConn_Call) Run(run func(ctx context.Context, in *_go.IPsecUnloadConnReq, opts ...grpc.CallOption)) *IPsecClient_IPsecUnloadConn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*_go.IPsecUnloadConnReq), variadicArgs...)
	})
	return _c
}

func (_c *IPsecClient_IPsecUnloadConn_Call) Return(_a0 *_go.IPsecUnloadConnResp, _a1 error) *IPsecClient_IPsecUnloadConn_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IPsecClient_IPsecUnloadConn_Call) RunAndReturn(run func(context.Context, *_go.IPsecUnloadConnReq, ...grpc.CallOption) (*_go.IPsecUnloadConnResp, error)) *IPsecClient_IPsecUnloadConn_Call {
	_c.Call.Return(run)
	return _c
}

// IPsecVersion provides a mock function with given fields: ctx, in, opts
func (_m *IPsecClient) IPsecVersion(ctx context.Context, in *_go.IPsecVersionReq, opts ...grpc.CallOption) (*_go.IPsecVersionResp, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *_go.IPsecVersionResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecVersionReq, ...grpc.CallOption) (*_go.IPsecVersionResp, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *_go.IPsecVersionReq, ...grpc.CallOption) *_go.IPsecVersionResp); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*_go.IPsecVersionResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *_go.IPsecVersionReq, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IPsecClient_IPsecVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IPsecVersion'
type IPsecClient_IPsecVersion_Call struct {
	*mock.Call
}

// IPsecVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - in *_go.IPsecVersionReq
//   - opts ...grpc.CallOption
func (_e *IPsecClient_Expecter) IPsecVersion(ctx interface{}, in interface{}, opts ...interface{}) *IPsecClient_IPsecVersion_Call {
	return &IPsecClient_IPsecVersion_Call{Call: _e.mock.On("IPsecVersion",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *IPsecClient_IPsecVersion_Call) Run(run func(ctx context.Context, in *_go.IPsecVersionReq, opts ...grpc.CallOption)) *IPsecClient_IPsecVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*_go.IPsecVersionReq), variadicArgs...)
	})
	return _c
}

func (_c *IPsecClient_IPsecVersion_Call) Return(_a0 *_go.IPsecVersionResp, _a1 error) *IPsecClient_IPsecVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IPsecClient_IPsecVersion_Call) RunAndReturn(run func(context.Context, *_go.IPsecVersionReq, ...grpc.CallOption) (*_go.IPsecVersionResp, error)) *IPsecClient_IPsecVersion_Call {
	_c.Call.Return(run)
	return _c
}

// NewIPsecClient creates a new instance of IPsecClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIPsecClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IPsecClient {
	mock := &IPsecClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
